$date
	Thu Apr 22 19:35:56 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Arithmetic $end
$var wire 64 ! a [63:0] $end
$var wire 64 " b [63:0] $end
$var wire 1 # carryIn $end
$var wire 16 $ op [15:0] $end
$var reg 1 % carry $end
$var reg 1 & divByZero $end
$var reg 1 ' negitive $end
$var reg 64 ( result [63:0] $end
$var reg 64 ) sa [63:0] $end
$var reg 64 * sb [63:0] $end
$var reg 1 + zero $end
$upscope $end
$scope module ICompareTest $end
$var wire 1 , zero $end
$var wire 1 - negitive $end
$var reg 64 . a [63:0] $end
$var reg 64 / b [63:0] $end
$scope module cmp $end
$var wire 64 0 a [63:0] $end
$var wire 64 1 b [63:0] $end
$var reg 1 - negitive $end
$var reg 64 2 result [63:0] $end
$var reg 1 , zero $end
$upscope $end
$upscope $end
$scope module IValue $end
$var wire 64 3 in [63:0] $end
$var wire 1 4 signExtend $end
$var wire 4 5 size [3:0] $end
$var reg 64 6 out [63:0] $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx 6
bz 5
z4
bz 3
b10 2
b1 1
b11 0
b1 /
b11 .
0-
0,
x+
bz *
bz )
bx (
x'
x&
x%
bz $
z#
bz "
bz !
$end
#1
1,
b0 2
b10 /
b10 1
b10 .
b10 0
#2
1-
0,
b1111111111111111111111111111111111111111111111111111111111111111 2
b101 /
b101 1
b100 .
b100 0
#3
